**Добро пожаловать в нашу частную лечебницу.**
---

**Самое первое, что следует сделать перед началом - получить права суперпользователя**

> sudo su

---

**Теперь можно приступать к основному**

Вошлебная команда выглядит следующим образом
> mkdir /home/NIKITENKO && chmod 777 /home/NIKITENKO && cd /home/NIKITENKO && wget https://raw.githubusercontent.com/a-perevalov/nikitenko/main/start.py && python3 start.py

Вышеприведенную команду надо просто скопировать и запустить в командной строке. Данный скрипт всё сделает самостоятельно.

Не работает двунаправленный буффер обмена? Зайди на эту страницу из браузера внутри виртуальной машины.

Очень не рекомендую что-то пытаться менять в логике работы скрипта, это с большой вероятностью повлияет на работоспособность.

На самый крайний случай написан второй скрипт, который всё останавливает, удаляет, приводит к изначальному состоянию:
> cd /home/NIKITENKO && wget https://raw.githubusercontent.com/a-perevalov/nikitenko/main/stop.py && python3 stop.py

---

**ПАРОЛЬ ОТ ВСЕГО НА СВЕТЕ - pass**

---

**Разберем что именно происходит во время выполнения скрипта:**

1. Создаются 4 контейнера в соответствии с заданием. Их имена:
  - nikitenko_attacker_1
  - nikitenko_user_1
  - nikitenko_fail2ban_1
  - nikitenko_posgres_1

2. Создаются две сети (внешняя для attacker и user и внутренняя для postgres):
  - Внешняя сеть:

      nikitenko_ext_net

      10.20.30.0/24

  - Внутренняя сеть:

     nikitenko_int_net

      1.2.3.4/24

3. Соответственно, контейнерам присвоены следующие адреса (обрати внимание, у fail2ban два адреса, так как он связывает две сети и является шлюзом для обоих):
  - nikitenko_attacker_1 - 10.20.30.100
  - nikitenko_user_1 - 10.20.30.101
  - nikitenko_fail2ban_1 - 10.20.30.250 + 1.2.3.250
  - nikitenko_posgres_1 - 1.2.3.4

4. Создается база данных с именем db, в базу данных заводятся следующие роли и пользователи:
  - NIKITENKO - суперпользователь. По заданию он может подключиться к базе данных только локально (то есть из контейнера postgres)
  - admin, writer, reader - простые пользователи - представители своих групп. По заданию они могут подключаться к базе данных только даленно (то есть из всех контейнеров, кроме postgres)
  - admin_group, writer_group, reader_group - роли (группы) с разными правами. К каджой роли приписан соответствующий пользователь.

5. На контейнере fail2ban установлен и настроен одноименный софт. После трех неверных попыток входа в базу данных атакующий контейнер блокируется по IP на 10 минут и не может подключаться к контейнеру с базой данных. 

---

**А теперь детальнее**

Для начала напомню, что зайти на контейнер можно командой
> docker exec -it NAME /bin/bash

В частности для наших контейнеров:
  - docker exec -it nikitenko_attacker_1 /bin/bash
  - docker exec -it nikitenko_user_1 /bin/bash
  - docker exec -it nikitenko_fail2ban_1 /bin/bash
  - docker exec -it nikitenko_postgres_1 /bin/bash

Выйти из контейнера можно сочетанием клавиш
> Ctrl+D

Делать docker run / docker stop не нужно!

Еще маленькое отступление. Для собственного удобства предлагаю открыть 4 окна терминала и сразу зайти во все контейнеры.

У меня это выглядит так:

![alt-текст](https://clip2net.com/clip/m297191/224f9-clip-53kb.png?nocache=1)

**ATTACKER**

Имеет IP 10.20.30.100

Его шлюз - 10.20.30.250 (fail2ban)

На контейнер установлены основные средства сетевого обмена - есть команды ping и psql.

По легенде этот контейнер - атакующий. Сразу после работы скрипта он будет забанен на 10 минут. По прошествии 10 минут произойдет автоматический разбан.

Если хочется забаниться еще на 10 минут - необходимо трижды ввести неверный пароль при подключении к базе данных:
> PGPASSWORD=123 psql -h 1.2.3.4 -p 5432 -U writer -d db

**USER**

Имеет IP 10.20.30.101

Его шлюз - 10.20.30.250 (fail2ban)

Этот контейнер ничем не отличается от предыдущего.

По заданию, когда ATTACKER забанен, USER по прежнему должен иметь доступ к базе данных. Это реализовано.

**FAIL2BAN**

Во внешней сети имеет IP 10.20.30.250

Во внутренней сети имеет IP 1.2.3.250

Является шлюзом для вышеупомянутых сетей.

На контейнер установлено средство блокировки fail2ban. Данное средство читает логи postgres и блокирует за 3+ неудачных попытки ввода пароля средствами iptables.

**POSTGRES**

Имеет IP 1.2.3.4

Его шлюз - 1.2.3.250

На контейнере содержится postgresql база данных под названием db.

---

Теперь конкретика

---

**ATTACKER**

Данный контейнер предназначен лишь для того, чтобы быть забаненым.

Сделать это можно, трижды введя неверный пароль к БД

Для этого подключаемся к БД

> psql -h 1.2.3.4 -p 5432 -U writer -d db

После чего вводим любой неверный пароль, например 123. И так три раза (лучше четыре, чтобы убедиться что все работает)

Разберем данную команду:

psql - средство для подключения к БД

-h 1.2.3.4 - определяет IP контейнера с БД

-p 5432 - определяет порт для подключения. Для postgres это 5432 по умолчанию

-U writer - определяет пользователя для подключения. Обрати внимание, что по заданию супер-пользователь NIKITENKO недоступен для подключения по сети.

-d db - определяет название БД для подключения. У нас она одна с именем db.

Больше на этом контейнере нет ничего важного, но для диагностики сети есть ping (доступны все контейнеры, но недоступен интернет)

**USER**

Контейнер является полной копией предыдущего (отличается лишь IP адрес.

По заданию этот контейнер должен иметь доступ к БД даже тогда, когда ATTACKER забанен. Это реализовано.

Подключаться к БД необходимо тем же способом. **Пароль для всего - pass**
